#!/usr/bin/env ruby
# -*- encoding: UTF-8 -*-

# Setup paths.
root_dir = File.expand_path(File.dirname(__FILE__) + "/..")
$:.unshift File.join(root_dir, "lib")

require_relative "../config/boot"
require "stats_processor"
require "hive"

$0 = "hive"

args = ARGV.dup
args = ["start"] if args.empty?

# Run a single processor in the foreground.
if args[0] == "run"
  pclass = args[1].split("::").inject(Kernel) { |m, n| m.const_get(n) } rescue nil
  raise "Unknown processor." unless pclass

  logger.debug "Running"
  while Worker.work(pclass)
    logger.debug "Job processed"
  end

  exit
end

class MyServer < DaemonSpawn::Base

  def start(args)
    $0 = app_name
    pclass = app_name.split("::").inject(Kernel) { |m, n| m.const_get(n) } rescue nil
    raise "Unknown processor." unless pclass
    Hive::Pool.new(app_name, Hive::Policy.policy).run_in_worker(ENV["PROCESSOR"]) do
      Worker.work(pclass)
    end
  end

  def stop
    puts "Forcing stop"
  end
end

# Setup redis.
Redis::Initializer.config(root_dir, rack_env)

# Read configuration.
config = YAML.load_file("#{root_dir}/config/hive.yml")
defaults = config.delete("defaults")

config.each do |processor, options|
  options = defaults.merge(options || {})
  MyServer.spawn!({
    :log_file    => File.expand_path("log/#{processor}.log", root_dir),
    :pid_file    => "/tmp/#{processor}.pid",
    :sync_log    => true,
    :working_dir => root_dir,
    :timeout     => 10,
    :signal      => "QUIT",
    :application => processor
  }, args.dup)
end
